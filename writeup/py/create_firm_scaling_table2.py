#!/usr/bin/env python3
"""Generate a two-panel regression table for the Firm-Scaling specification.

This consolidates the OLS and IV variants. Use ``--model-type`` to select the
underlying model (``ols`` or ``iv``). The script adjusts query filters,
output paths and caption text accordingly. Kleibergen--Paap rows are included
only for the IV specification.
"""

from __future__ import annotations

import argparse
from pathlib import Path
import pandas as pd
import textwrap

# ---------------------------------------------------------------------------
# Paths and constants
# ---------------------------------------------------------------------------
HERE = Path(__file__).resolve().parent
PROJECT_ROOT = HERE.parents[1]

SPEC = "firm_scaling"
RAW_DIR = PROJECT_ROOT / "results" / "raw"
INPUT_BASE = RAW_DIR / SPEC / "consolidated_results.csv"
INPUT_ALT = RAW_DIR / f"{SPEC}_alternative_fe" / "consolidated_results.csv"
# Baseline (single-instrument) specification
INPUT_INIT = RAW_DIR / f"{SPEC}_initial" / "consolidated_results.csv"

PARAM_ORDER = ["var3", "var5"]
PARAM_LABEL = {
    "var3": r"$ \text{Remote} \times \mathds{1}(\text{Post}) $",
    "var5": r"$ \text{Remote} \times \mathds{1}(\text{Post}) \times \text{Startup} $",
}

# All outcomes generated by Stata
OUTCOME_LABEL = {
    "growth_rate_we": "Growth",
    "join_rate_we": "Join",
    "leave_rate_we": "Leave",
}




TAG_ORDER = [
    "init",  # 0) Baseline – Firm × Time FE
    "fyh",   # 1) Firm × Time FE with startup interaction
]

# ---------------------------------------------------------------------------
# Column configuration for the mini-report panel
#   (1) Growth – init FE
#   (2) Growth – fyh FE
#   (3) Join   – fyh FE
#   (4) Leave  – fyh FE
# ---------------------------------------------------------------------------

COL_CONFIG = [
    ("growth_rate_we", "init"),  # (1)
    ("growth_rate_we", "fyh"),   # (2)
    ("join_rate_we",   "fyh"),   # (3)
    ("leave_rate_we",  "fyh"),   # (4)
]

# Human-readable column header text for outcomes
OUTCOME_LABEL_MINI = {
    "growth_rate_we": "Growth",
    "join_rate_we":   "Join",
    "leave_rate_we":  "Leave",
}

# Column labels "(1)…(4)"
COL_LABELS = [f"({i})" for i in range(1, len(COL_CONFIG) + 1)]

# Mapping used to place \checkmark symbols in the indicator rows.  Any tag
# omitted from the dict defaults to ``False`` via ``dict.get`` in
# ``indicator_row``.
FIRM_FE_INCLUDED = {tag: True for tag in TAG_ORDER}

# Generic year FE (yh) only appears in `fyh` among the displayed tags.
TIME_FE_INCLUDED = {
    "init": True,
    "fyh": True,
}

# Additional interacted FE dimensions ---------------------------------------
# Industry × Time FE indicators (none after column pruning)
IND_FE_INCLUDED = {tag: False for tag in TAG_ORDER}

# HQ × Time FE indicators
HQ_FE_INCLUDED = {tag: False for tag in TAG_ORDER}

STAR_RULES = [(0.01, "***"), (0.05, "**"), (0.10, "*")]

TOP = r"\toprule"
MID = r"\midrule"
BOTTOM = r"\bottomrule"
PANEL_SEP = r"\specialrule{\lightrulewidth}{0pt}{0pt}"
PANEL_GAP = r"\addlinespace[0.75em]"

TABLE_WIDTH = r"\textwidth"

# ---------------------------------------------------------------------------
# Helper functions
# ---------------------------------------------------------------------------

def stars(p: float) -> str:
    for cut, sym in STAR_RULES:
        if p < cut:
            return sym
    return ""


COEF_DECIMALS = 3  # number of decimal places for scaling table coefficients


def cell(coef: float, se: float, p: float) -> str:
    fmt = f"{{coef:.{COEF_DECIMALS}f}}"
    se_fmt = f"{{se:.{COEF_DECIMALS}f}}"
    return rf"\makecell[c]{{{coef:.{COEF_DECIMALS}f}{stars(p)}\\({se:.{COEF_DECIMALS}f})}}"


def indicator_row(label: str, mapping: dict[str, bool], tag_order: list[str] = TAG_ORDER) -> str:
    checks = [r"$\checkmark$" if mapping.get(tag, False) else "" for tag in tag_order]
    return " & ".join([label] + checks) + r" \\"


def build_obs_row(df: pd.DataFrame, keys: list[str], *, filter_expr: str) -> str:
    cells = ["N"]
    for k in keys:
        sub = df.query(filter_expr.format(k=k))
        n = int(sub.iloc[0]["nobs"]) if not sub.empty else 0
        cells.append(f"{n:,}")
    return " & ".join(cells) + r" \\"


def build_pre_mean_row(df: pd.DataFrame, keys: list[str], *, filter_expr: str) -> str:
    """Return a row showing pre-COVID means for each column."""
    import pandas as pd

    cells = ["Pre-COVID mean"]
    for k in keys:
        sub = df.query(filter_expr.format(k=k)).head(1)
        val = sub.iloc[0]["pre_mean"] if "pre_mean" in sub.columns and not sub.empty else float("nan")
        cells.append(f"{val:.2f}" if pd.notna(val) else "")
    return " & ".join(cells) + r" \\"


def build_kp_row(df: pd.DataFrame, keys: list[str], *, filter_expr: str) -> str:
    import pandas as pd
    cells = ["KP rk Wald F"]
    for k in keys:
        sub = df.query(filter_expr.format(k=k)).head(1)
        val = sub.iloc[0]["rkf"] if not sub.empty else float("nan")
        cells.append(f"{val:.2f}" if pd.notna(val) else "")
    return " & ".join(cells) + r" \\"

# ---------------------------------------------------------------------------
# Panel builders
# ---------------------------------------------------------------------------

def build_panel_base(df: pd.DataFrame, model: str, include_kp: bool) -> str:
    ncols = 1 + len(OUTCOME_LABEL_B)
    panel_row = rf"\multicolumn{{{ncols}}}{{@{{}}l}}{{\textbf{{\uline{{Panel B: Additional Outcomes}}}}}}\\"
    panel_row += "\n\\addlinespace"

    # Header spanning the remaining outcome columns.  The number of columns
    # adapts automatically to ``OUTCOME_LABEL_B`` so that "Growth" can be
    # dropped without requiring manual updates.
    dep_hdr = rf" & \multicolumn{{{len(COL_CONFIG)}}}{{c}}{{Outcome}} \\"
    cmid    = rf"\cmidrule(lr){{2-{ncols}}}"
    sub_hdr = " & ".join(["", *[OUTCOME_LABEL_B[o] for o in OUTCOME_LABEL_B]]) + r" \\"  # outcomes

    rows = []
    for param in PARAM_ORDER:
        cells = [PARAM_LABEL[param]]
        for out in OUTCOME_LABEL_B:
            sub = df.query("model_type==@model and outcome==@out and param==@param")
            cells.append(cell(*sub.iloc[0][['coef', 'se', 'pval']]) if not sub.empty else "")
        rows.append(" & ".join(cells) + r" \\")
    coef_block = "\n".join(rows)

    pre_mean_row = build_pre_mean_row(
        df,
        list(OUTCOME_LABEL_B),
        filter_expr=f"model_type=='{model}' and outcome=='{{k}}'",
    )

    obs_row = build_obs_row(
        df,
        list(OUTCOME_LABEL_B),
        filter_expr=f"model_type=='{model}' and outcome=='{{k}}'",
    )

    kp_row = build_kp_row(
        df,
        list(OUTCOME_LABEL_B),
        filter_expr=f"model_type=='{model}' and outcome=='{{k}}'",
    ) if include_kp else ""

    # One ``l`` column for the parameter label followed by as many centred
    # numeric columns as there are outcomes to display.
    col_fmt = r"@{}l@{\extracolsep{\fill}}" + "c" * len(OUTCOME_LABEL_B) + r"@{}"
    top = ""
    bottom = BOTTOM
    return textwrap.dedent(rf"""
    \begin{{tabular*}}{{{TABLE_WIDTH}}}{{{col_fmt}}}
    {top}
    {panel_row}
    {dep_hdr}
    {cmid}
    {sub_hdr}
    {MID}
    {coef_block}
    {MID}
    {pre_mean_row}
    {obs_row}
    {kp_row}
    {bottom}
    \end{{tabular*}}""")

# ---------------------------------------------------------------------------
#  Mini-report single-panel builder (overwrites earlier draft)
# ---------------------------------------------------------------------------

# Redefine `build_panel_fe` so that it now constructs a single four-column panel
# driven by `COL_CONFIG`.  The second definition replaces the placeholder above
# when the module is imported / executed.


def build_panel_fe(df: pd.DataFrame, model: str, include_kp: bool) -> str:  # noqa: C901 – complexity acceptable for table builder
    """Return a *single* LaTeX panel for the firm-scaling table.

    The four displayed columns are configured via ``COL_CONFIG``.
    Each tuple ``(outcome, tag)`` specifies both the dependent variable and
    the fixed-effect variant to fetch from the consolidated regression output.
    """

    # ------------------------------------------------------------------
    # Column metadata and header
    # ------------------------------------------------------------------
    ncols = 1 + len(COL_CONFIG)
    tags_in_cols = [tag for _, tag in COL_CONFIG]

    # Outcome super-header and individual outcome names -------------------
    dep_hdr = rf" & \multicolumn{{{len(COL_CONFIG)}}}{{c}}{{Outcome}} \\"
    cmid    = rf"\cmidrule(lr){{2-{ncols}}}"
    sub_hdr = " & ".join(["", *[OUTCOME_LABEL_MINI[out] for out, _ in COL_CONFIG]]) + r" \\"  # noqa: W605

    # Simple numeric column labels "(1)…(4)"
    header = " & ".join(["", *COL_LABELS]) + r" \\"  # noqa: W605

    # ------------------------------------------------------------------
    # Coefficient rows
    # ------------------------------------------------------------------
    coef_lines: list[str] = []
    for param in PARAM_ORDER:
        row_cells = [PARAM_LABEL[param]]
        for outcome, tag in COL_CONFIG:
            sub = df.query(
                "model_type==@model and outcome==@outcome and fe_tag==@tag and param==@param"
            )
            row_cells.append(
                cell(*sub.iloc[0][["coef", "se", "pval"]]) if not sub.empty else ""
            )
        coef_lines.append(" & ".join(row_cells) + r" \\")
    coef_block = "\n".join(coef_lines)

    # ------------------------------------------------------------------
    # Statistic rows – Observations and KP rk Wald F (IV only)
    # ------------------------------------------------------------------
    # Observations
    obs_cells = ["N"]
    for outcome, tag in COL_CONFIG:
        sub = df.query(
            "model_type==@model and outcome==@outcome and fe_tag==@tag"
        ).head(1)
        nobs = int(sub.iloc[0]["nobs"]) if not sub.empty else 0
        obs_cells.append(f"{nobs:,}")
    obs_row = " & ".join(obs_cells) + r" \\"  # noqa: W605

    # KP rk Wald F (IV only)
    if include_kp:
        kp_cells = ["KP rk Wald F"]
        for outcome, tag in COL_CONFIG:
            sub = df.query(
                "model_type==@model and outcome==@outcome and fe_tag==@tag"
            ).head(1)
            val = sub.iloc[0]["rkf"] if not sub.empty else float("nan")
            kp_cells.append(f"{val:.2f}" if pd.notna(val) else "")
        kp_row = " & ".join(kp_cells) + r" \\"  # noqa: W605
    else:
        kp_row = ""

    # ------------------------------------------------------------------
    # Indicator rows – retain only Time and Firm FE indicators
    # ------------------------------------------------------------------
    indicator_lines = "\n".join(
        [
            indicator_row("Time FE", TIME_FE_INCLUDED, tag_order=tags_in_cols),
            indicator_row("Firm FE", FIRM_FE_INCLUDED, tag_order=tags_in_cols),
        ]
    )

    # ------------------------------------------------------------------
    # Assemble table
    # ------------------------------------------------------------------
    col_fmt = r"@{}l@{\extracolsep{\fill}}" + "c" * len(COL_CONFIG) + r"@{}"

    bottom_rule = BOTTOM

    return textwrap.dedent(rf"""
    \begin{{tabular*}}{{{TABLE_WIDTH}}}{{{col_fmt}}}
    {TOP}
    {dep_hdr}
    {cmid}
    {sub_hdr}
    {header}
    {MID}
    {coef_block}
    {MID}
    {indicator_lines}
    {MID}
    {obs_row}
    {kp_row}
    {bottom_rule}
    \end{{tabular*}}""")


# Legacy version kept for reference – no longer used in mini-report
def _build_panel_fe_legacy(df: pd.DataFrame, model: str, include_kp: bool) -> str:
    ncols = 1 + len(TAG_ORDER)
    panel_row = rf"\multicolumn{{{ncols}}}{{@{{}}l}}{{\textbf{{\uline{{Panel A: Growth}}}}}}\\"
    panel_row += "\n\\addlinespace"

    dep_hdr = ""
    cmid = ""
    header = " & ".join(["", *COL_LABELS]) + r" \\"  # column labels

    rows = []
    for param in PARAM_ORDER:
        cells = [PARAM_LABEL[param]]
        for tag in TAG_ORDER:
            sub = df.query(
                "model_type==@model and outcome=='growth_rate_we' and fe_tag==@tag and param==@param"
            )
            cells.append(cell(*sub.iloc[0][['coef', 'se', 'pval']]) if not sub.empty else "")
        rows.append(" & ".join(cells) + r" \\")
    coef_block = "\n".join(rows)

    
    obs_row = build_obs_row(
        df,
        TAG_ORDER,
        filter_expr=f"model_type=='{model}' and outcome=='growth_rate_we' and fe_tag=='{{k}}'",
    )

    kp_row = build_kp_row(
        df,
        TAG_ORDER,
        filter_expr=f"model_type=='{model}' and outcome=='growth_rate_we' and fe_tag=='{{k}}'",
    ) if include_kp else ""

    # Only the core FE indicators retained for the mini report
    ind_rows = "\n".join([
        indicator_row("Time FE", TIME_FE_INCLUDED),
        indicator_row("Firm FE", FIRM_FE_INCLUDED),
    ])

    col_fmt = r"@{}l@{\extracolsep{\fill}}" + "c" * len(TAG_ORDER) + r"@{}"
    top = TOP
    bottom = (MID + "\n" + PANEL_GAP) if include_kp else PANEL_SEP
    return textwrap.dedent(rf"""
    \begin{{tabular*}}{{{TABLE_WIDTH}}}{{{col_fmt}}}
    {top}
    {panel_row}
    {dep_hdr}
    {cmid}
    {header}
    {MID}
    {coef_block}
    {MID}
    {ind_rows}
    {MID}
    {obs_row}
    {kp_row}
    {bottom}
    \end{{tabular*}}""")

# ---------------------------------------------------------------------------
# Main driver
# ---------------------------------------------------------------------------

def main() -> None:
    parser = argparse.ArgumentParser(description="Create firm scaling regression table")
    parser.add_argument("--model-type", choices=["ols", "iv"], default="ols")
    args = parser.parse_args()

    model = "IV" if args.model_type.lower() == "iv" else "OLS"
    include_kp = model == "IV"

    output_tex = PROJECT_ROOT / "results" / "cleaned" / f"{SPEC}_{args.model_type}.tex"
    caption = f"Firm Scaling {model}"
    label = f"tab:firm_scaling_{args.model_type}"

    if not INPUT_ALT.exists():
        raise FileNotFoundError(f"Missing alternative FE CSV: {INPUT_ALT}")

    if not INPUT_INIT.exists():
        raise FileNotFoundError(INPUT_INIT)

    df_alt = pd.read_csv(INPUT_ALT)
    df_init = pd.read_csv(INPUT_INIT).copy()
    df_init["fe_tag"] = "init"
    df_fe = pd.concat([df_init, df_alt], ignore_index=True)

    tex_lines = [
        "% Auto-generated firm scaling table",
        "",
        r"\begin{table}[H]",
        r"\centering",
        rf"\caption{{{caption}}}",
        rf"\label{{{label}}}",
        r"\centering",
        build_panel_fe(df_fe, model, include_kp).rstrip(),
        r"\end{table}",
    ]

    output_tex.parent.mkdir(parents=True, exist_ok=True)
    Path(output_tex).write_text("\n".join(tex_lines) + "\n")
    print(f"Wrote LaTeX table to {output_tex.resolve()}")


if __name__ == "__main__":
    main()
